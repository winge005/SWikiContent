[h1] How to Manage Transactions in Redis on Java 

[p]Transactions in Redis allow the execution of a group of commands to take place in a single step. Managing Redis transactions on Java can be tricky for some users, but it is much easier when you have the right tools at your disposal. In this post, you will learn all you need to know about the execution of Redis transactions on Java, as well as getting a brief insight into Spring Transaction Manager and XA Transactions for Redis.[|p]

[h2] Overview of Redis Transactions on Java

[p]Redis transactions are atomic, meaning that either all the commands in the transaction are processed or none of them are. The commands are sequentially executed as a single isolated operation, with no option for a request issued by another client to be served in the middle of the execution of the transaction.[|p]
[p]Redis transactions are founded on four commands: MULTI, EXEC, DISCARD, and WATCH. The MULTI command allows a user to issue multiple commands, which are all executed when the user calls EXEC. Even if a command in the list of multiple commands fails, all the other commands in the queue will still be processed. If this occurs, the user will see an error message.[|p]
[p]Redisson is a Redis Java client that allows us to execute Transactions on Java with isolation level  READ_COMMITTED. Some examples of objects that could participate in Java Transaction are RMap, RMapCache, RLocalCachedMap, RSet, RSetCache, and RBucket. Supported Redis modes are:[|p]

[l]   	SINGLE			[|l]
[l]    	MASTER/SLAVE	[|l]
[l]    	SENTINEL		[|l]	
[l]		ELASTICACHE REPLICATED[|l]
[l]    	AZURE CACHE[|l]
[l]    	RLEC[|l]
[br]

[p]There are several options that the user can supply during the creation of a Transaction. These include:[|p]

[bq]
TransactionOptions options = TransactionOptions.defaults()[br]
[br]
// Synchronization data timeout between Redis master participating in transaction and its slaves.[br]
// Default is 5000 milliseconds[br]
options.syncSlavesTimeout(5, TimeUnit.SECONDS);[br]
[br]
// Response timeout[br]
// Default is 3000 milliseconds[br]
options.responseTimeout(3, TimeUnit.SECONDS);[br]
[br]
// Defines time interval for each attempt to send transaction if it hasn't been sent already.[br]
// Default is 1500 milliseconds[br]
options.retryInterval(2, TimeUnit.SECONDS)[br]
[br]
// Defines attempts amount to send transaction if it hasn't been sent already.[br]
// Default is 3 attempts[br]
options.retryAttempts(3)[br]
[br]
// If transaction hasn't been committed within timeout it will be rolledback automatically.[br]
// Default is 5000 milliseconds[br]
options.timeout(5, TimeUnit.SECONDS);[br]
[|bq]

[h2] Spring Transaction Manager for Redis

[|p]Redisson enables participation in Spring transactions through the implementation of  org.springframework.transaction.PlatformTransactionManager.[|p]
[|p]The first step is to configure Redisson to enable transaction management:[|p]

[bq]
@Configuration[br]
@EnableTransactionManagementpublic [br]
public class RedissonTransactionContextConfig {[br]
[br]
    @Bean [br]
    public TransactionalBean transactionBean() {[br]
        return new TransactionalBean(); [br]
    } [br]
[br]
    @Bean public RedissonTransactionManager transactionManager(RedissonClient redisson) { [br]
        return new RedissonTransactionManager(redisson); [br]
    } [br]
[br]
    @Bean [br]
    public RedissonClient redisson() { [br]
        return BaseTest.createInstance(); [br]
    }[br]
[br]
    @PreDestroy[br]
    public void destroy() { [br]
      redisson().shutdown(); [br]
    }[br]
}[br]
[br]
public class TransactionalBean { [br]
    @Autowired [br]
    private RedissonTransactionManager transactionManager; [br]
[br]
    @Transactional [br]
    public void commitData() { [br]
        RTransaction transaction = transactionManager.getCurrentTransaction(); [br]
        RMap map = transaction.getMap("test1"); map.put("1", "2"); [br]
    }[br]
}[br]
[|bq]

[p]You can then use Spring Transaction Manager to manage transactions in Redis.[|p]

[h2] XA Transactions in Redis

[p]Redisson also provides XAResource implementation. This allows the participation of JTA transactions to perform distributed Transaction processing.  Here is an example of execution XA Transactions in Redisson:[|p]

[bq]
// transaction obtained from JTA compatible transaction manager[br]
Transaction globalTransaction = transactionManager.getTransaction();[br]
[br]
RXAResource xaResource = redisson.getXAResource();[br]
globalTransaction.enlistResource(xaResource);[br]
[br]
RTransaction transaction = xaResource.getTransaction();[br]
RBucket<String> bucket = transaction.getBucket("myBucket");[br]
bucket.set("simple");[br]
RMap<String, String> map = transaction.getMap("myMap");[br]
map.put("myKey", "myValue");[br]
[br]
transactionManager.commit();[br]
[|bq]

[h2] Conclusion

[p]Redisson provides several features that can make it easier for users to manage transactions in Redis. These include Spring Transaction Manager and XAResource implementation. These features are extremely useful for a large number of Redis users who are looking to make use of Java transactions on Redis.[|p]
