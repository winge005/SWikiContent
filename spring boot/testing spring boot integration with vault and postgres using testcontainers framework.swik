[h1] Testing Spring Boot Integration With Vault and Postgres Using Testcontainers Framework 

[p]I have already written many articles where I was using Docker containers for running some third-party solutions integrated with my sample applications. Building integration tests for such applications may not be an easy task without Docker containers. Especially if our application integrates with databases, message brokers, or some other popular tools. If you are planning to build such integration tests, you should definitely take a look on Testcontainers.[|p]
[p]Testcontainers is a Java library that supports JUnit tests, providing a fast and lightweight way for running instances of common databases, Selenium web browsers, or anything else that can run in a Docker container. It provides modules for the most popular relational and NoSQL databases like Postgres, MySQL, Cassandra, or Neo4j. It also allows running popular products like Elasticsearch, Kafka, Nginx, or HashiCorp's Vault. Today, I'm going to show you a more advanced sample of JUnit tests that use Testcontainers to check out an integration between Spring Boot/Spring Cloud application, Postgres database, and Vault.[|p]
[p]For the purposes of that example, we will use the case described in one of my previous articles Secure Spring Cloud Microservices with Vault and Nomad. Let us recall that use case.[|p]
[p]I described there how to use a very interesting Vault feature called secret engines for generating database user credentials dynamically. I used Spring Cloud Vault module in my Spring Boot application to automatically integrate with that feature of Vault. The implemented mechanism is pretty easy. The application calls Vault secret engine before it tries to connect to Postgres database on startup. Vault is integrated with Postgres via secret engine, and that's why it creates a user with sufficient privileges on Postgres. Then, generated credentials are automatically injected into auto-configured Spring Boot properties used for connecting with database spring.datasource.username and spring.datasource.password. The following picture illustrates the described solution:[|p]

[img|testcontainers-128129.png][br]
[br]

[p]Ok, we know how it works, now the question is how to automatically test it. With Testcontainers, it is possible with just a few lines of code.[|p]

[h2] 1. Building the Application

[p]Let's begin with a short intro to the application code; it is very simple. Here's the list of dependencies required for building an application that exposes REST API and integrates with Postgres and Vault.[|p]

[bq]
<dependency>[br]
[id1]    <groupId>org.springframework.boot</groupId>[br]
[id1]    <artifactId>spring-boot-starter-web</artifactId>[br]
</dependency>[br]
<dependency>[br]
[id1]    <groupId>org.springframework.cloud</groupId>[br]
[id1]    <artifactId>spring-cloud-starter-vault-config</artifactId>[br]
</dependency>[br]
<dependency>[br]
[id1]    <groupId>org.springframework.cloud</groupId>[br]
[id1]    <artifactId>spring-cloud-vault-config-databases</artifactId>[br]
</dependency>[br]
<dependency>[br]
[id1]    <groupId>org.springframework.boot</groupId>[br]
[id1]    <artifactId>spring-boot-starter-data-jpa</artifactId>[br]
</dependency>[br]
<dependency>[br]
[id1]    <groupId>org.postgresql</groupId>[br]
[id1]    <artifactId>postgresql</artifactId>[br]
[id1]    <version>42.2.5</version>[br]
</dependency>[br]
[|bq]

[p]The application connects to Postgres, enables integration with Vault via Spring Cloud Vault, and automatically creates/updates tables on startup.[|p]

[bq]
spring:[br]
[id1]  application:[br]
[id2]    name: callme-service[br]
[id1]  cloud:[br]
   [id3] vault:[br]
      [id4]uri: http://192.168.99.100:8200[br]
      [id4]token: ${VAULT_TOKEN}[br]
      [id4]postgresql:[br]
        [id5]enabled: true[br]
        [id5]role: default[br]
        [id5]backend: database[br]
[id1]  datasource:[br]
[id2]    url: jdbc:postgresql://192.168.99.100:5432/postgres[br]
[id1]  jpa.hibernate.ddl-auto: update[br]
[|bq]

[p]It exposes the single endpoint. The following method is responsible for handling incoming requests. It just inserts a record to the database and returns a response with the app name, version, and ID of the inserted record.[|p]

[bq]
@RestController[br]
@RequestMapping("/callme")[br]
public class CallmeController {[br]
[br]
[id1]    private static final Logger LOGGER = LoggerFactory.getLogger(CallmeController.class);[br]
[id1]    @Autowired[br]
[br]
[id1]    Optional<BuildProperties> buildProperties;[br]
[id1]    @Autowired[br]
[id1]    CallmeRepository repository;[br]
[br]
[id1]    @GetMapping("/message/{message}")[br]
[id1]    public String ping(@PathVariable("message") String message) {[br]
    [id2]    Callme c = repository.save(new Callme(message, new Date()));[br]
[br]
    [id2]    if (buildProperties.isPresent()) {[br]
        [id3]    BuildProperties infoProperties = buildProperties.get();[br]
        [id3]    LOGGER.info("Ping: name={}, version={}", infoProperties.getName(), infoProperties.getVersion());[br]
        [id3]    return infoProperties.getName() + ":" + infoProperties.getVersion() + ":" + c.getId();[br]
    [id2]    } else {[br]
         [id3]   return "callme-service:"  + c.getId();[br]
    [id2]    }[br]
[id1]    }[br]
}[br]
[|bq]

[h2] 2. Enabling Testcontainers

[p]To enable Testcontainers for our project, we need to include some dependencies to our Maven pom.xml. We have dedicated modules for Postgres and Vault. We also include a Spring Boot Test dependency because we would like to test the whole Spring Boot app.[|p]

[bq]
<dependency>[br]
[id1]    <groupId>org.springframework.boot</groupId>[br]
[id1]    <artifactId>spring-boot-starter-test</artifactId>[br]
[id1]    <scope>test</scope>[br]
</dependency>[br]
<dependency>[br]
[id1]    <groupId>org.testcontainers</groupId>[br]
[id1]    <artifactId>vault</artifactId>[br]
[id1]    <version>1.10.5</version>[br]
[id1]    <scope>test</scope>[br]
</dependency>[br]
[br]
<dependency>[br]
[id1]    <groupId>org.testcontainers</groupId>[br]
[id1]    <artifactId>testcontainers</artifactId>[br]
[id1]    <version>1.10.5</version>[br]
[id1]    <scope>test</scope>[br]
</dependency>[br]
[br]
<dependency>[br]
[id1]    <groupId>org.testcontainers</groupId>[br]
[id1]    <artifactId>postgresql</artifactId>[br]
[id1]    <version>1.10.5</version>[br]
[id1]    <scope>test</scope>[br]
</dependency>[br]
[|bq]

[h2] 3. Running Vault Test Container

Testcontainers framework supports JUnit 4/JUnit 5 and Spock. The Vault container can be started before tests if it is annotated with @Rule or @ClassRule. By default, it uses version 0.7, but we can override it with the newest version, which is 1.0.2. We also may set a root token, which is then required by Spring Cloud Vault for integration with Vault.

[bq]
@ClassRule[br]
public static VaultContainer vaultContainer = new VaultContainer<>("vault:1.0.2")[br]
[id1]    .withVaultToken("123456")[br]
[id1]    .withVaultPort(8200);[br]
[|bq]

[p]That root token can be overridden before starting the JUnit test on the test class.[|p]

[bq]
@RunWith(SpringRunner.class)[br]
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT, properties = {[br]
[id1]    "spring.cloud.vault.token=123456"[br]
})[br]
[br]
public class CallmeTest { ... }[br]
[|bq]

[h2] 4. Running Postgres Test Container

[p]As an alternative to @ClassRule, we can manually start the container in a @BeforeClass or @Before method in the test. With this approach, you will also have to stop it manually in @AfterClass or @After method. We start Postgres container manually because by default, it is exposed on a dynamically generated port, which needs to be set for Spring Boot application before starting the test. The listen port is returned by method getFirstMappedPort invoked on PostgreSQLContainer.[|p]

[bq]
private static PostgreSQLContainer postgresContainer = new PostgreSQLContainer()[br]
[id1]    .withDatabaseName("postgres")[br]
[id1]    .withUsername("postgres")[br]
[id1]    .withPassword("postgres123");[br]
[br]
@BeforeClass[br]
public static void init() throws IOException, InterruptedException {[br]
[br]
[id1]    postgresContainer.start();[br]
[id1]    int port = postgresContainer.getFirstMappedPort();[br]
[id1]    System.setProperty("spring.datasource.url", String.format("jdbc:postgresql://192.168.99.100:%d/postgres", postgresContainer.getFirstMappedPort()));[br]
[id1]    // ...[br]
}[br]
[br]
@AfterClass[br]
public static void shutdown() {[br]
[id1]    postgresContainer.stop();[br]
}[br]
[|bq]

[h2] 5. Integrating Vault and Postgres Containers

[p]Once we have successfully started both Vault and Postgres containers, we need to integrate them via Vault secret engine. First, we need to enable the database secret engine Vault. After that, we must configure the connection to Postgres. The last step is to configure a role. A role is a logical name that maps to a policy used to generate those credentials. All these actions may be performed using Vault commands. You can launch a command on the Vault container using execInContainer method. Vault configuration commands should be executed just after Postgres container startup.[|p]

[bq]
@BeforeClass[br]
public static void init() throws IOException, InterruptedException {[br]
[id1]    postgresContainer.start();[br]
[id1]    int port = postgresContainer.getFirstMappedPort();[br]
[id1]    System.setProperty("spring.datasource.url", String.format("jdbc:postgresql://192.168.99.100:%d/postgres", postgresContainer.getFirstMappedPort()));[br]
[id1]    vaultContainer.execInContainer("vault", "secrets", "enable", "database");[br]
[id1]    String url = String.format("connection_url=postgresql://{{username}}:{{password}}@192.168.99.100:%d?sslmode=disable", port);[br]
[id1]    vaultContainer.execInContainer("vault", "write", "database/config/postgres", "plugin_name=postgresql-database-plugin", "allowed_roles=default", url, "username=postgres", "password=postgres123");[br]
[id1]    vaultContainer.execInContainer("vault", "write", "database/roles/default", "db_name=postgres",[br]
     [id2]   "creation_statements=CREATE ROLE \"{{name}}\" WITH LOGIN PASSWORD '{{password}}' VALID UNTIL '{{expiration}}';GRANT SELECT, UPDATE, INSERT ON ALL TABLES IN SCHEMA public TO \"{{name}}\";GRANT USAGE,  SELECT ON ALL SEQUENCES IN SCHEMA public TO \"{{name}}\";",[br]
     [id2]   "default_ttl=1h", "max_ttl=24h");[br]
}[br]
[|bq]

[h2] 6. Running Application Tests

[p]Finally, we may run application tests. We just call the single endpoint exposed by the app using TestRestTemplate, and verify the output.[|p]

[bq]
@Autowired[br]
TestRestTemplate template;[br]
[br]
@Test[br]
public void test() {[br]
[id1]    String res = template.getForObject("/callme/message/{message}", String.class, "Test");[br]
[id1]    Assert.assertNotNull(res);[br]
[id1]    Assert.assertTrue(res.endsWith("1"));[br]
}[br]
[|bq]

[p]If you are interested in what exactly happens during the test, you can set a breakpoint inside the test method and execute the docker ps command manually.[|p]

[img|testcontainers-2.png][br]
[br]